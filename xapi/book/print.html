<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mike&#x27;s X API Blog</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mike&#x27;s X API Blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mikes-x-developer-api-blog"><a class="header" href="#mikes-x-developer-api-blog">Mike's X Developer API Blog</a></h1>
<hr />
<blockquote>
<p><em>"How about 'Hook into what's happening', y'know for our slogan!"</em></p>
<p><em>"Mike that's awful"</em></p>
<p><em>"Yeah..."</em></p>
</blockquote>
<p>Hey everyone, thanks for checking out my tutorial.</p>
<p>My name is Mike Rosinsky. I'm a software engineer on the X Developer Platform team, and I wanted to make a blog-style page to showcase some fun demos and other things relating to the API.</p>
<p>This doesn't intend to serve as a replacement for docs, but maybe can give some good insight into what you can create with the APIs that X offers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-webhooks-with-the-x-developer-api"><a class="header" href="#using-webhooks-with-the-x-developer-api">Using Webhooks with the X Developer API</a></h1>
<blockquote>
<p>☎️ Don't call us, we'll call you!</p>
</blockquote>
<h2 id="whats-a-webhook"><a class="header" href="#whats-a-webhook">What's a Webhook?</a></h2>
<p>Webhooks are an efficient way to receive real-time data from the X Developer API. It's an industry standard practice, and a growing number of X's products currently support webhooks.</p>
<p>Instead of polling the API servers to check if any new data is available on a regular interval, the API will reach out to you automatically!</p>
<p>You register your server's callback URL with X, and when new data becomes available that matches your criteria, the API will reach out to your server, deliver the event, and disconnect.</p>
<p>This is all secured using industry standard encryption, making it an ideal choice for efficient, event-driven data delivery.</p>
<p>A growing number of X's real-time products support webhook delivery. These products include:</p>
<ul>
<li>Filtered Stream</li>
<li>Account Activity API</li>
<li>X Activity API</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-basic-webhook-app"><a class="header" href="#writing-a-basic-webhook-app">Writing a Basic Webhook App</a></h1>
<p>In this section, we'll write a basic app to get started with receiving webhook events from X.</p>
<p>Here's the requests that the app will need to handle:</p>
<ul>
<li><code>GET</code> requests for security challenge checks</li>
<li><code>POST</code> requests for receiving events</li>
</ul>
<p>After we make the app, we'll need to host it with a public-facing HTTPS URL. I'll show you some options for quick, free methods for getting this stood up quickly so you can test.</p>
<h2 id="the-basic-app"><a class="header" href="#the-basic-app">The Basic App</a></h2>
<p>Let's start with a basic skeleton for our webhook app. We'll build it incrementally, adding features step by step.</p>
<pre><code class="language-python">from flask import Flask
from waitress import serve

HOST = "0.0.0.0"
PORT = 8080

app = Flask(__name__)

@app.route('/webhooks', methods=['GET', 'POST'])
def webhook_request():

    if request.method == 'GET':
        # Stub - we'll implement the security check here
        print("Got GET request")
        return '', 200

    elif request.method == 'POST':
        # Stub - we'll implement webhook event handling here
        print("Got POST request")
        return '', 200

    # Got an invalid method
    return 'Method Not Allowed', 405

def main():
    print(f"Hosting WSGI server on {HOST}:{PORT}")
    serve(app, host=HOST, port=PORT)

if __name__=='__main__':
    main()
</code></pre>
<p>This gives us a basic Flask app with stub endpoints for both GET and POST requests. Now let's implement each part step by step.</p>
<h2 id="implementing-the-security-check-get-request"><a class="header" href="#implementing-the-security-check-get-request">Implementing the Security Check (GET Request)</a></h2>
<p>X uses a Challenge-Response Check (CRC) to verify that your webhook endpoint is legitimate and secure. When you register a webhook URL, X will send a GET request with a <code>crc_token</code> parameter. Your app must respond with an HMAC SHA-256 hash of that token using your consumer secret.</p>
<h3 id="getting-your-consumer-secret"><a class="header" href="#getting-your-consumer-secret">Getting Your Consumer Secret</a></h3>
<p>To get your consumer secret, go to your X Developer Portal and navigate to your app's settings. You'll find the Consumer Keys section where you can view and regenerate your API keys:</p>
<p><img src="chapter_1/../../../assets/keys.png" alt="Finding your consumer secret in the X Developer Portal" /></p>
<p>Copy the "API Key Secret" (also called Consumer Secret) and set it as an environment variable before running your app.</p>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h3>
<p>The CRC check ensures that:</p>
<ul>
<li>Your endpoint is accessible and responding</li>
<li>Only you (with your consumer secret) can validate the webhook</li>
<li>The connection between X and your server is secure</li>
</ul>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>First, let's add the necessary imports and environment variable setup:</p>
<pre><code class="language-python">from flask import Flask, request, jsonify
from waitress import serve

import base64
import hashlib
import hmac
import os
import json
import sys

app = Flask(__name__)

# Your Twitter consumer secret - set this as an environment variable
CONSUMER_SECRET = os.environ.get("CONSUMER_SECRET")
if CONSUMER_SECRET is None:
  print("Missing consumer secret. Ensure CONSUMER_SECRET env var is set.")
  sys.exit(1)

HOST = "0.0.0.0"
PORT = 8080
</code></pre>
<p>Now let's implement the GET request handler:</p>
<pre><code class="language-python">@app.route('/webhooks', methods=['GET', 'POST'])
def webhook_request():
    # Handle GET request (CRC challenge)
    if request.method == 'GET':
        crc_token = request.args.get('crc_token')
        print(f"CRC Token received: {crc_token}")

        if crc_token is None:
            print("Error: No crc_token found in the request.")
            return json.dumps({'error': 'No crc_token'})

        # Creates HMAC SHA-256 hash from incoming token and your consumer secret
        sha256_hash_digest = hmac.new(
            CONSUMER_SECRET.encode('utf-8'),
            msg=crc_token.encode('utf-8'),
            digestmod=hashlib.sha256
        ).digest()

        # Construct response data with base64 encoded hash
        response = {
            'response_token': 'sha256=' + base64.b64encode(sha256_hash_digest).decode('utf-8')
        }

        # Returns properly formatted json response
        return jsonify(response)

    elif request.method == 'POST':
        # Stub - we'll implement webhook event handling here
        print("Got POST request")
        return 'Not implemented yet', 501

    # Got an invalid method
    return 'Method Not Allowed', 405
</code></pre>
<h3 id="how-the-crc-check-works"><a class="header" href="#how-the-crc-check-works">How the CRC Check Works</a></h3>
<ol>
<li><strong>X sends a challenge</strong>: GET request with <code>crc_token</code> parameter</li>
<li><strong>You create an HMAC hash</strong>: Using SHA-256 with your consumer secret and the token</li>
<li><strong>You respond</strong>: With <code>{"response_token": "sha256=&lt;base64_hash&gt;"}</code></li>
<li><strong>X verifies</strong>: Compares your hash with what they expect</li>
</ol>
<h2 id="implementing-webhook-events-post-request"><a class="header" href="#implementing-webhook-events-post-request">Implementing Webhook Events (POST Request)</a></h2>
<p>Now let's implement the POST request handler to receive actual webhook events from X.</p>
<p>Replace the POST stub with this implementation:</p>
<pre><code class="language-python">@app.route('/webhooks', methods=['GET', 'POST'])
def webhook_request():
    # Handle GET request (CRC challenge)
    if request.method == 'GET':
        # Truncated...

    # Handle POST request (Webhook event)
    elif request.method == 'POST':
        # Use the json library to render and dump the data.
        event_data = request.get_json()
        if event_data:
            print(json.dumps(event_data, indent=2))
        else:
            # Log if the request body wasn't JSON or was empty
            print(f"Body: {request.data.decode('utf-8')}")

        # Return 200 OK to acknowledge receipt
        return '', 200

    # Got an invalid method
    return 'Method Not Allowed', 405
</code></pre>
<h3 id="processing-events"><a class="header" href="#processing-events">Processing Events</a></h3>
<p>The POST handler:</p>
<ol>
<li><strong>Parses the JSON payload</strong> from the request body</li>
<li><strong>Logs the event data</strong> for debugging and processing</li>
<li><strong>Returns 200 OK</strong> to acknowledge successful receipt</li>
<li><strong>Handles edge cases</strong> like non-JSON payloads</li>
</ol>
<h2 id="running-the-complete-app"><a class="header" href="#running-the-complete-app">Running the Complete App</a></h2>
<p>Now that we have both GET and POST implemented, let's add a proper main function:</p>
<pre><code class="language-python">def main():
    print("--- Starting Webhook App ---")
    print(f"Using CONSUMER_SECRET from environment variable.")
    print(f"Running with Waitress WSGI server on {HOST}:{PORT}")
    serve(app, host=HOST, port=PORT)

if __name__ == '__main__':
    main()
</code></pre>
<p>To run the app:</p>
<ol>
<li>
<p>Set your consumer secret:</p>
<pre><code class="language-bash">export CONSUMER_SECRET="your_consumer_secret_here"
</code></pre>
</li>
<li>
<p>Run the app:</p>
<pre><code class="language-bash">python sample_app.py
</code></pre>
</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Your webhook app is now complete! To use it:</p>
<ol>
<li><strong>Host it publicly</strong> with HTTPS (required for webhooks)</li>
<li><strong>Register the URL</strong> in your X Developer Portal</li>
<li><strong>Configure your webhook</strong> to listen for specific events</li>
<li><strong>Test with real events</strong> as they occur</li>
</ol>
<p>The app will now properly handle both the security challenge and incoming webhook events from X.</p>
<h2 id="the-complete-code"><a class="header" href="#the-complete-code">The Complete Code</a></h2>
<p>Here's the complete, working webhook app that combines everything we've built:</p>
<pre><code class="language-python">from flask import Flask, request, jsonify
from waitress import serve

import base64
import hashlib
import hmac
import os
import json
import sys

app = Flask(__name__)

# Your Twitter consumer secret - set this as an environment variable
CONSUMER_SECRET = os.environ.get("CONSUMER_SECRET")
if CONSUMER_SECRET is None:
  print("Missing consumer secret. Ensure CONSUMER_SECRET env var is set.")
  sys.exit(1)

HOST = "0.0.0.0"
PORT = 8080

@app.route('/webhooks', methods=['GET', 'POST'])
def webhook_request():
    # Handle GET request (CRC challenge)
    if request.method == 'GET':
        crc_token = request.args.get('crc_token')
        print(f"CRC Token received: {crc_token}")

        if crc_token is None:
            print("Error: No crc_token found in the request.")
            return json.dumps({'error': 'No crc_token'})

        # Creates HMAC SHA-256 hash from incoming token and your consumer secret
        sha256_hash_digest = hmac.new(
            CONSUMER_SECRET.encode('utf-8'),
            msg=crc_token.encode('utf-8'),
            digestmod=hashlib.sha256
        ).digest()

        # Construct response data with base64 encoded hash
        response = {
            'response_token': 'sha256=' + base64.b64encode(sha256_hash_digest).decode('utf-8')
        }

        # Returns properly formatted json response
        return jsonify(response)

    # Handle POST request (Webhook event)
    elif request.method == 'POST':
        # Use the json library to render and dump the data.
        event_data = request.get_json()
        if event_data:
            print(json.dumps(event_data, indent=2))
        else:
            # Log if the request body wasn't JSON or was empty
            print(f"Body: {request.data.decode('utf-8')}")

        # Return 200 OK to acknowledge receipt
        return '', 200

    # Got an invalid method
    return 'Method Not Allowed', 405

def main():
    print("--- Starting Webhook App ---")
    print(f"Using CONSUMER_SECRET from environment variable.")
    print(f"Running with Waitress WSGI server on {HOST}:{PORT}")
    serve(app, host=HOST, port=PORT)

if __name__ == '__main__':
    main()
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that the server is running locally, you'll need to host it to generate a publicly-available HTTPS URL.</p>
<p>This can be done for free using public tools like <code>ngrok</code>, deployed to a cloud environment, or any other means you wish.</p>
<p>In the next section, we'll register the URL with X so we can start receiving events.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registering-a-webhook-with-x"><a class="header" href="#registering-a-webhook-with-x">Registering a Webhook With X</a></h1>
<p>Registering a webhook involves passing the HTTPS URL for your webhook app to X's servers, so they know where to send events to.</p>
<p>The official docs are here: https://docs.x.com/x-api/webhooks/introduction</p>
<h2 id="routes"><a class="header" href="#routes">Routes</a></h2>
<p>The X API offers the following endpoints to manage your registered webhooks:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Route</th><th>Description</th></tr></thead><tbody>
<tr><td><code>GET</code></td><td><code>/2/webhooks</code></td><td>List all registered webhooks for your account</td></tr>
<tr><td><code>POST</code></td><td><code>/2/webhooks</code></td><td>Create a webhook (see below for JSON body)</td></tr>
<tr><td><code>DELETE</code></td><td><code>/2/webhooks/:webhook_id</code></td><td>Delete a webhook by ID</td></tr>
<tr><td><code>PUT</code></td><td><code>/2/webhooks/:webhook_id</code></td><td>Manually trigger a security check to re-validate a webhook</td></tr>
</tbody></table>
</div>
<h2 id="register-a-webhook"><a class="header" href="#register-a-webhook">Register a Webhook</a></h2>
<p>To register the webhook, you'll use the <code>POST</code> route, along with the following JSON body:</p>
<pre><code class="language-json">{
    "url": "&lt;YOUR WEBHOOK HTTPS URL&gt;"
}
</code></pre>
<p>We can use <code>curl</code> to test this:</p>
<pre><code class="language-bash">curl https://api.x.com/2/webhooks -X POST -d '{"url": "&lt;YOUR WEBHOOK HTTPS URL&gt;"}'
</code></pre>
<p>When this request is sent, X will send a <code>GET</code> request to the provided URL to validate that the webhook belongs to you.</p>
<p>This is the security check we demonstrated in the last section.</p>
<p>On successful validation, the webhook will be created:</p>
<pre><code class="language-json">"data": {
  "created_at": "2025-10-15T20:53:05.000Z",
  "id": "1146654567674912769",
  "url": "&lt;YOUR WEBHOOK HTTPS URL&gt;",
  "valid": true
}
</code></pre>
<h2 id="list-your-webhooks"><a class="header" href="#list-your-webhooks">List your Webhooks</a></h2>
<p>Now we can call the <code>GET</code> route to see our registered webhooks:</p>
<pre><code class="language-bash">curl https://api.x.com/2/webhooks
</code></pre>
<pre><code class="language-json">{
  "data":[
    {
      "created_at":"2025-10-15T20:53:05.000Z",
      "id":"1146654567674912769",
      "url":"&lt;YOUR WEBHOOK HTTPS URL&gt;",
      "valid":true
    }
  ],
  "meta":{
    "result_count":1
  }
}
</code></pre>
<h2 id="re-validating-your-webhook"><a class="header" href="#re-validating-your-webhook">Re-validating your webhook</a></h2>
<p>At regular intervals (~24hrs), X will attempt to validate that your webhook is still operational.</p>
<p>X does this by sending the <code>GET</code> CRC check again.</p>
<p>If for some reason this validation fails, the webhook will be marked as <code>"valid":false</code> and will no longer receive events.</p>
<p>To re-validate the webhook, you can call the <code>PUT</code> request, which will manually trigger the re-validation process:</p>
<pre><code class="language-bash">curl https://api.x.com/2/webhooks/1146654567674912769 -X PUT 
</code></pre>
<p>Providing the validation was successful, our webhook will be re-validated:</p>
<pre><code class="language-json">{
  "data":{
    "valid":true
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
