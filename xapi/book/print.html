<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mike&#x27;s X API Blog</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mike&#x27;s X API Blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mikes-x-developer-api-blog"><a class="header" href="#mikes-x-developer-api-blog">Mike's X Developer API Blog</a></h1>
<hr />
<blockquote>
<p><em>"How about 'Hook into what's happening', y'know for our slogan!"</em></p>
<p><em>"Mike that's awful"</em></p>
<p><em>"Yeah..."</em></p>
</blockquote>
<p>Hey everyone, thanks for checking out my tutorial.</p>
<p>My name is Mike Rosinsky. I'm a software engineer on the X Developer Platform team, and I wanted to make a blog-style page to showcase some fun demos and other things relating to the API.</p>
<p>This doesn't intend to serve as a replacement for docs, but maybe can give some good insight into what you can create with the APIs that X offers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xurl---curl-for-x"><a class="header" href="#xurl---curl-for-x">xURL - cURL for X</a></h1>
<p><code>xURL</code> is a CLI tool specifically design for interfacing with the X API.</p>
<p>Some key features include:</p>
<ul>
<li>URL shortening</li>
<li>Authentication handling</li>
<li>Webhook testing via ngrok</li>
</ul>
<p>You can check out the full project, including the README here: <a href="https://github.com/xdevplatform/xurl" target="_blank">https://github.com/xdevplatform/xurl</a></p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Install the tool with one curl command:</p>
<pre><code class="language-bash">curl -fsSL https://raw.githubusercontent.com/xdevplatform/xurl/main/install.sh | sudo bash
</code></pre>
<p>Register your auth token:</p>
<pre><code class="language-bash">xurl auth app --bearer-token YOUR_BEARER_TOKEN
</code></pre>
<p>and make requests:</p>
<pre><code class="language-bash">xurl --auth app /2/tweets/20
</code></pre>
<p>Check out the xurl github README for further tutorials including using OAuth1 + 2, user auth, and other features.</p>
<p>I'll be using xurl in all sample commands in follow-on sections in this blog.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-webhooks-with-the-x-developer-api"><a class="header" href="#using-webhooks-with-the-x-developer-api">Using Webhooks with the X Developer API</a></h1>
<blockquote>
<p>☎️ Don't call us, we'll call you!</p>
</blockquote>
<h2 id="whats-a-webhook"><a class="header" href="#whats-a-webhook">What's a Webhook?</a></h2>
<p>Webhooks are an efficient way to receive real-time data from the X Developer API. It's an industry standard practice, and a growing number of X's products currently support webhooks.</p>
<p>Instead of polling the API servers to check if any new data is available on a regular interval, the API will reach out to you automatically!</p>
<p>You register your server's callback URL with X, and when new data becomes available that matches your criteria, the API will reach out to your server, deliver the event, and disconnect.</p>
<p>This is all secured using industry standard encryption, making it an ideal choice for efficient, event-driven data delivery.</p>
<p>A growing number of X's real-time products support webhook delivery. These products include:</p>
<ul>
<li>Filtered Stream</li>
<li>Account Activity API</li>
<li>X Activity API</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-basic-webhook-app"><a class="header" href="#writing-a-basic-webhook-app">Writing a Basic Webhook App</a></h1>
<p>In this section, we'll write a basic app to get started with receiving webhook events from X.</p>
<p>Here's the requests that the app will need to handle:</p>
<ul>
<li><code>GET</code> requests for security challenge checks</li>
<li><code>POST</code> requests for receiving events</li>
</ul>
<p>After we make the app, we'll need to host it with a public-facing HTTPS URL. I'll show you some options for quick, free methods for getting this stood up quickly so you can test.</p>
<h2 id="the-basic-app"><a class="header" href="#the-basic-app">The Basic App</a></h2>
<p>Let's start with a basic skeleton for our webhook app. We'll build it incrementally, adding features step by step.</p>
<pre><code class="language-python">from flask import Flask
from waitress import serve

HOST = "0.0.0.0"
PORT = 8080

app = Flask(__name__)

@app.route('/webhooks', methods=['GET', 'POST'])
def webhook_request():

    if request.method == 'GET':
        # Stub - we'll implement the security check here
        print("Got GET request")
        return '', 200

    elif request.method == 'POST':
        # Stub - we'll implement webhook event handling here
        print("Got POST request")
        return '', 200

    # Got an invalid method
    return 'Method Not Allowed', 405

def main():
    print(f"Hosting WSGI server on {HOST}:{PORT}")
    serve(app, host=HOST, port=PORT)

if __name__=='__main__':
    main()
</code></pre>
<p>This gives us a basic Flask app with stub endpoints for both GET and POST requests. Now let's implement each part step by step.</p>
<h2 id="implementing-the-security-check-get-request"><a class="header" href="#implementing-the-security-check-get-request">Implementing the Security Check (GET Request)</a></h2>
<p>X uses a Challenge-Response Check (CRC) to verify that your webhook endpoint is legitimate and secure. When you register a webhook URL, X will send a GET request with a <code>crc_token</code> parameter. Your app must respond with an HMAC SHA-256 hash of that token using your consumer secret.</p>
<h3 id="getting-your-consumer-secret"><a class="header" href="#getting-your-consumer-secret">Getting Your Consumer Secret</a></h3>
<p>To get your consumer secret, go to your X Developer Portal and navigate to your app's settings. You'll find the Consumer Keys section where you can view and regenerate your API keys:</p>
<p><img src="2_realtime/1_webhooks/../../../assets/keys.png" alt="Finding your consumer secret in the X Developer Portal" /></p>
<p>Copy the "API Key Secret" (also called Consumer Secret) and set it as an environment variable before running your app.</p>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h3>
<p>The CRC check ensures that:</p>
<ul>
<li>Your endpoint is accessible and responding</li>
<li>Only you (with your consumer secret) can validate the webhook</li>
<li>The connection between X and your server is secure</li>
</ul>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>First, let's add the necessary imports and environment variable setup:</p>
<pre><code class="language-python">from flask import Flask, request, jsonify
from waitress import serve

import base64
import hashlib
import hmac
import os
import json
import sys

app = Flask(__name__)

# Your Twitter consumer secret - set this as an environment variable
CONSUMER_SECRET = os.environ.get("CONSUMER_SECRET")
if CONSUMER_SECRET is None:
  print("Missing consumer secret. Ensure CONSUMER_SECRET env var is set.")
  sys.exit(1)

HOST = "0.0.0.0"
PORT = 8080
</code></pre>
<p>Now let's implement the GET request handler:</p>
<pre><code class="language-python">@app.route('/webhooks', methods=['GET', 'POST'])
def webhook_request():
    # Handle GET request (CRC challenge)
    if request.method == 'GET':
        crc_token = request.args.get('crc_token')
        print(f"CRC Token received: {crc_token}")

        if crc_token is None:
            print("Error: No crc_token found in the request.")
            return json.dumps({'error': 'No crc_token'})

        # Creates HMAC SHA-256 hash from incoming token and your consumer secret
        sha256_hash_digest = hmac.new(
            CONSUMER_SECRET.encode('utf-8'),
            msg=crc_token.encode('utf-8'),
            digestmod=hashlib.sha256
        ).digest()

        # Construct response data with base64 encoded hash
        response = {
            'response_token': 'sha256=' + base64.b64encode(sha256_hash_digest).decode('utf-8')
        }

        # Returns properly formatted json response
        return jsonify(response)

    elif request.method == 'POST':
        # Stub - we'll implement webhook event handling here
        print("Got POST request")
        return 'Not implemented yet', 501

    # Got an invalid method
    return 'Method Not Allowed', 405
</code></pre>
<h3 id="how-the-crc-check-works"><a class="header" href="#how-the-crc-check-works">How the CRC Check Works</a></h3>
<ol>
<li><strong>X sends a challenge</strong>: GET request with <code>crc_token</code> parameter</li>
<li><strong>You create an HMAC hash</strong>: Using SHA-256 with your consumer secret and the token</li>
<li><strong>You respond</strong>: With <code>{"response_token": "sha256=&lt;base64_hash&gt;"}</code></li>
<li><strong>X verifies</strong>: Compares your hash with what they expect</li>
</ol>
<h2 id="implementing-webhook-events-post-request"><a class="header" href="#implementing-webhook-events-post-request">Implementing Webhook Events (POST Request)</a></h2>
<p>Now let's implement the POST request handler to receive actual webhook events from X.</p>
<p>Replace the POST stub with this implementation:</p>
<pre><code class="language-python">@app.route('/webhooks', methods=['GET', 'POST'])
def webhook_request():
    # Handle GET request (CRC challenge)
    if request.method == 'GET':
        # Truncated...

    # Handle POST request (Webhook event)
    elif request.method == 'POST':
        # Use the json library to render and dump the data.
        event_data = request.get_json()
        if event_data:
            print(json.dumps(event_data, indent=2))
        else:
            # Log if the request body wasn't JSON or was empty
            print(f"Body: {request.data.decode('utf-8')}")

        # Return 200 OK to acknowledge receipt
        return '', 200

    # Got an invalid method
    return 'Method Not Allowed', 405
</code></pre>
<h3 id="processing-events"><a class="header" href="#processing-events">Processing Events</a></h3>
<p>The POST handler:</p>
<ol>
<li><strong>Parses the JSON payload</strong> from the request body</li>
<li><strong>Logs the event data</strong> for debugging and processing</li>
<li><strong>Returns 200 OK</strong> to acknowledge successful receipt</li>
<li><strong>Handles edge cases</strong> like non-JSON payloads</li>
</ol>
<h2 id="running-the-complete-app"><a class="header" href="#running-the-complete-app">Running the Complete App</a></h2>
<p>Now that we have both GET and POST implemented, let's add a proper main function:</p>
<pre><code class="language-python">def main():
    print("--- Starting Webhook App ---")
    print(f"Using CONSUMER_SECRET from environment variable.")
    print(f"Running with Waitress WSGI server on {HOST}:{PORT}")
    serve(app, host=HOST, port=PORT)

if __name__ == '__main__':
    main()
</code></pre>
<p>To run the app:</p>
<ol>
<li>
<p>Set your consumer secret:</p>
<pre><code class="language-bash">export CONSUMER_SECRET="your_consumer_secret_here"
</code></pre>
</li>
<li>
<p>Run the app:</p>
<pre><code class="language-bash">python sample_app.py
</code></pre>
</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Your webhook app is now complete! To use it:</p>
<ol>
<li><strong>Host it publicly</strong> with HTTPS (required for webhooks)</li>
<li><strong>Register the URL</strong> in your X Developer Portal</li>
<li><strong>Configure your webhook</strong> to listen for specific events</li>
<li><strong>Test with real events</strong> as they occur</li>
</ol>
<p>The app will now properly handle both the security challenge and incoming webhook events from X.</p>
<h2 id="the-complete-code"><a class="header" href="#the-complete-code">The Complete Code</a></h2>
<p>Here's the complete, working webhook app that combines everything we've built:</p>
<pre><code class="language-python">from flask import Flask, request, jsonify
from waitress import serve

import base64
import hashlib
import hmac
import os
import json
import sys

app = Flask(__name__)

# Your Twitter consumer secret - set this as an environment variable
CONSUMER_SECRET = os.environ.get("CONSUMER_SECRET")
if CONSUMER_SECRET is None:
  print("Missing consumer secret. Ensure CONSUMER_SECRET env var is set.")
  sys.exit(1)

HOST = "0.0.0.0"
PORT = 8080

@app.route('/webhooks', methods=['GET', 'POST'])
def webhook_request():
    # Handle GET request (CRC challenge)
    if request.method == 'GET':
        crc_token = request.args.get('crc_token')
        print(f"CRC Token received: {crc_token}")

        if crc_token is None:
            print("Error: No crc_token found in the request.")
            return json.dumps({'error': 'No crc_token'})

        # Creates HMAC SHA-256 hash from incoming token and your consumer secret
        sha256_hash_digest = hmac.new(
            CONSUMER_SECRET.encode('utf-8'),
            msg=crc_token.encode('utf-8'),
            digestmod=hashlib.sha256
        ).digest()

        # Construct response data with base64 encoded hash
        response = {
            'response_token': 'sha256=' + base64.b64encode(sha256_hash_digest).decode('utf-8')
        }

        # Returns properly formatted json response
        return jsonify(response)

    # Handle POST request (Webhook event)
    elif request.method == 'POST':
        # Use the json library to render and dump the data.
        event_data = request.get_json()
        if event_data:
            print(json.dumps(event_data, indent=2))
        else:
            # Log if the request body wasn't JSON or was empty
            print(f"Body: {request.data.decode('utf-8')}")

        # Return 200 OK to acknowledge receipt
        return '', 200

    # Got an invalid method
    return 'Method Not Allowed', 405

def main():
    print("--- Starting Webhook App ---")
    print(f"Using CONSUMER_SECRET from environment variable.")
    print(f"Running with Waitress WSGI server on {HOST}:{PORT}")
    serve(app, host=HOST, port=PORT)

if __name__ == '__main__':
    main()
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that the server is running locally, you'll need to host it to generate a publicly-available HTTPS URL.</p>
<p>This can be done for free using public tools like <code>ngrok</code>, deployed to a cloud environment, or any other means you wish.</p>
<p>In the next section, we'll register the URL with X so we can start receiving events.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standing-up-a-temporary-webhook-using-xurl"><a class="header" href="#standing-up-a-temporary-webhook-using-xurl">Standing up a Temporary Webhook using xURL</a></h1>
<blockquote>
<p><strong>Note</strong>: This section assumes you have the <code>xurl</code> CLI tool set up. If you haven't installed and configured <code>xurl</code> yet, check out the <a href="2_realtime/1_webhooks/../../1_tools/1_xurl/xurl.html">xURL section</a> first.</p>
</blockquote>
<p>If you're looking for a quick and easy way to stand up a webhook to use with the X API, the xURL tool offers this functionality.</p>
<p>The xURL webhook abstracts away the need to write your own handlers for the GET and POST requests that X sends to your server. If you're looking for that logic to incorporate into your production app, check out the next section where we write a Python Flask app.</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>What you'll need:</p>
<ul>
<li>The xURL CLI tool (already installed and configured)</li>
<li>A free (or higher) account with <code>ngrok.com</code></li>
<li>Your ngrok auth token</li>
</ul>
<h2 id="setup-steps"><a class="header" href="#setup-steps">Setup Steps</a></h2>
<h3 id="1-register-your-oauth1-keys"><a class="header" href="#1-register-your-oauth1-keys">1. Register Your OAuth1 Keys</a></h3>
<p>First, ensure your OAuth1 keys are registered with xurl:</p>
<pre><code class="language-bash">xurl auth oauth1
</code></pre>
<p>You'll need to provide your consumer key and secret, and access key and secret. Generate these from the <a href="https://developer.x.com">X Developer Portal</a>.</p>
<h3 id="2-start-the-webhook-server"><a class="header" href="#2-start-the-webhook-server">2. Start the Webhook Server</a></h3>
<p>Run the xURL webhook command:</p>
<pre><code class="language-bash">xurl webhook start
</code></pre>
<p>You'll be prompted for your ngrok auth token so that xURL can create a temporary HTTPS endpoint:</p>
<pre><code>Starting webhook server with ngrok...
Enter your ngrok authtoken (leave empty to try NGROK_AUTHTOKEN env var):
</code></pre>
<p>Once you've entered your auth token, your endpoint will be generated and you'll see output like this:</p>
<pre><code>Configuring ngrok to forward to local port: 8080
Ngrok tunnel established!
  Forwarding URL: https://d1cb5181df5c.ngrok.app -&gt; localhost:8080
Use this URL for your X API webhook registration: https://d1cb5181df5c.ngrok.app/webhook
Starting local HTTP server to handle requests from ngrok tunnel (forwarded from https://d1cb5181df5c.ngrok.app)...
</code></pre>
<h2 id="using-your-webhook"><a class="header" href="#using-your-webhook">Using Your Webhook</a></h2>
<p>Leave the terminal window running - any webhook events, including the security check, will be displayed in that window.</p>
<p><strong>To stop the webhook server</strong>: Press <code>Ctrl+C</code> in the terminal.</p>
<p>You can now use the generated URL (ending in <code>/webhook</code>) to register a webhook with the X API. See the next section for a tutorial on webhook registration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registering-a-webhook-with-x"><a class="header" href="#registering-a-webhook-with-x">Registering a Webhook With X</a></h1>
<p>Registering a webhook involves passing the HTTPS URL for your webhook app to X's servers, so they know where to send events to.</p>
<p>The official docs are here: https://docs.x.com/x-api/webhooks/introduction</p>
<h2 id="routes"><a class="header" href="#routes">Routes</a></h2>
<p>The X API offers the following endpoints to manage your registered webhooks:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Route</th><th>Description</th></tr></thead><tbody>
<tr><td><code>GET</code></td><td><code>/2/webhooks</code></td><td>List all registered webhooks for your account</td></tr>
<tr><td><code>POST</code></td><td><code>/2/webhooks</code></td><td>Create a webhook (see below for JSON body)</td></tr>
<tr><td><code>DELETE</code></td><td><code>/2/webhooks/:webhook_id</code></td><td>Delete a webhook by ID</td></tr>
<tr><td><code>PUT</code></td><td><code>/2/webhooks/:webhook_id</code></td><td>Manually trigger a security check to re-validate a webhook</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note</strong>: All sample commands in this section use the <code>xurl</code> CLI tool. If you haven't set up <code>xurl</code> yet, check out the <a href="2_realtime/1_webhooks/../1_tools/1_xurl/xurl.html">xURL section</a> first.</p>
</blockquote>
<h2 id="register-a-webhook"><a class="header" href="#register-a-webhook">Register a Webhook</a></h2>
<p>To register the webhook, you'll use the <code>POST</code> route, along with the following JSON body:</p>
<pre><code class="language-json">{
    "url": "&lt;YOUR WEBHOOK HTTPS URL&gt;"
}
</code></pre>
<p>We can use <code>xurl</code> to test this:</p>
<pre><code class="language-bash">xurl --auth app /2/webhooks -X POST -d '{"url": "&lt;YOUR WEBHOOK HTTPS URL&gt;"}'
</code></pre>
<p>When this request is sent, X will send a <code>GET</code> request to the provided URL to validate that the webhook belongs to you.</p>
<p>This is the security check we demonstrated in the last section.</p>
<p>On successful validation, the webhook will be created:</p>
<pre><code class="language-json">"data": {
  "created_at": "2025-10-15T20:53:05.000Z",
  "id": "1146654567674912769",
  "url": "&lt;YOUR WEBHOOK HTTPS URL&gt;",
  "valid": true
}
</code></pre>
<h2 id="list-your-webhooks"><a class="header" href="#list-your-webhooks">List your Webhooks</a></h2>
<p>Now we can call the <code>GET</code> route to see our registered webhooks:</p>
<pre><code class="language-bash">xurl --auth app /2/webhooks
</code></pre>
<pre><code class="language-json">{
  "data":[
    {
      "created_at":"2025-10-15T20:53:05.000Z",
      "id":"1146654567674912769",
      "url":"&lt;YOUR WEBHOOK HTTPS URL&gt;",
      "valid":true
    }
  ],
  "meta":{
    "result_count":1
  }
}
</code></pre>
<h2 id="re-validating-your-webhook"><a class="header" href="#re-validating-your-webhook">Re-validating your webhook</a></h2>
<p>At regular intervals (~24hrs), X will attempt to validate that your webhook is still operational.</p>
<p>X does this by sending the <code>GET</code> CRC check again.</p>
<p>If for some reason this validation fails, the webhook will be marked as <code>"valid":false</code> and will no longer receive events.</p>
<p>To re-validate the webhook, you can call the <code>PUT</code> request, which will manually trigger the re-validation process:</p>
<pre><code class="language-bash">xurl --auth app /2/webhooks/1146654567674912769 -X PUT 
</code></pre>
<p>Providing the validation was successful, our webhook will be re-validated:</p>
<pre><code class="language-json">{
  "data":{
    "valid":true
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-x-activity-api"><a class="header" href="#the-x-activity-api">The X Activity API</a></h1>
<p>In this chapter, we'll use the webhook we set up in the previous chapter in conjunction with X's newest real-time data suite, the X Activity API.</p>
<h2 id="about"><a class="header" href="#about">About</a></h2>
<p>The X Activity API allows us to subscribe to event types and apply filters. When a matching event is created, it will be delivered to our app.</p>
<p>XAA offers both webhook and streaming support, but we'll be using the webhook option in this example.</p>
<h2 id="routes-1"><a class="header" href="#routes-1">Routes</a></h2>
<p>To manage our active subscriptions in XAA, we're offered the following routes:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Route</th><th>Description</th></tr></thead><tbody>
<tr><td><code>GET</code></td><td><code>/2/activity/subscriptions</code></td><td>List all active subscriptions</td></tr>
<tr><td><code>POST</code></td><td><code>/2/activity/subscriptions</code></td><td>Create a new subscription (see below for JSON body)</td></tr>
<tr><td><code>DELETE</code></td><td><code>/2/activity/subscriptions/:subscription_id</code></td><td>Delete a subscription by ID</td></tr>
<tr><td><code>PUT</code></td><td><code>/2/activity/subscriptions/:subscription_id</code></td><td>Update a subscription (see below for JSON body)</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note</strong>: All sample commands in this section use the <code>xurl</code> CLI tool. If you haven't set up <code>xurl</code> yet, check out the <a href="2_realtime/2_xaa/../../1_tools/1_xurl/xurl.html">xURL section</a> first.</p>
</blockquote>
<p>Let's run the <code>GET</code> route first just to ensure the route is working and our account has access.</p>
<p>You'll use your bearer token for authentication for all routes:</p>
<pre><code>xurl --auth app /2/activity/subscriptions
</code></pre>
<pre><code class="language-json">{
  "data":[
  ],
  "meta": {
    "total_subscriptions": 0
  }
}
</code></pre>
<p>Looks like everything's working. We currently have no active subscriptions.</p>
<h2 id="getting-your-user-id"><a class="header" href="#getting-your-user-id">Getting Your User ID</a></h2>
<p>Before creating a subscription, we need to know our user ID. The X Activity API requires user IDs (not usernames) in the filter criteria.</p>
<p>Let's get our user ID using the User Lookup endpoint:</p>
<pre><code class="language-bash">xurl --auth app /2/users/by/username/YOUR_USERNAME
</code></pre>
<p>Replace <code>YOUR_USERNAME</code> with your actual X username (without the @ symbol).</p>
<p><strong>Example response:</strong></p>
<pre><code class="language-json">{
  "data": {
    "id": "1234567890",
    "name": "Your Name",
    "username": "your_username"
  }
}
</code></pre>
<p>Copy the <code>id</code> value from the response - you'll need it for creating subscriptions.</p>
<h2 id="creating-a-subscription"><a class="header" href="#creating-a-subscription">Creating a Subscription</a></h2>
<p>Now let's create our first subscription. We'll subscribe to our own profile update events first, so we can test for an event coming through.</p>
<h3 id="subscription-parameters"><a class="header" href="#subscription-parameters">Subscription Parameters</a></h3>
<p>When creating a subscription, you need to specify:</p>
<ul>
<li><strong><code>event_type</code></strong>: The type of event to subscribe to (required)</li>
<li><strong><code>filter</code></strong>: Criteria to filter which events to receive (required)</li>
<li><strong><code>webhook_id</code></strong>: The ID of your registered webhook where events will be delivered (optional, but required for webhook delivery)</li>
<li><strong><code>tag</code></strong>: An optional identifier for your subscription (recommended)</li>
</ul>
<h3 id="available-event-types"><a class="header" href="#available-event-types">Available Event Types</a></h3>
<p>XAA supports several event types:</p>
<ul>
<li><code>ProfileBioUpdate</code> - When a user updates their bio</li>
<li><code>ProfilePictureUpdate</code> - When a user changes their profile picture</li>
<li><code>ProfileBannerPictureUpdate</code> - When a user changes their banner</li>
<li><code>ProfileScreennameUpdate</code> - When a user changes their username</li>
<li><code>ProfileGeoUpdate</code> - When a user updates their location</li>
<li><code>ProfileUrlUpdate</code> - When a user updates their website URL</li>
</ul>
<h3 id="creating-the-subscription"><a class="header" href="#creating-the-subscription">Creating the Subscription</a></h3>
<p>Let's create a subscription to monitor our own profile bio updates:</p>
<pre><code class="language-bash">xurl --auth app /2/activity/subscriptions -X POST -d '{
  "event_type": "ProfileBioUpdate",
  "filter": {
    "user_id": "YOUR_USER_ID"
  },
  "webhook_id": "YOUR_WEBHOOK_ID",
  "tag": "my bio updates"
}'
</code></pre>
<h3 id="success-response"><a class="header" href="#success-response">Success Response</a></h3>
<p>If successful, you'll receive a response like this:</p>
<pre><code class="language-json">{
  "data": {
    "subscription": {
      "created_at": "2025-10-07T05:31:56Z",
      "event_type": "ProfileBioUpdate",
      "filter": {
        "user_id": "YOUR_USER_ID"
      },
      "subscription_id": "1146654567674912769",
      "tag": "my bio updates",
      "updated_at": "2025-10-07T05:31:56Z",
      "webhook_id": "YOUR_WEBHOOK_ID"
    }
  },
  "meta": {
    "total_subscriptions": 1
  }
}
</code></pre>
<h2 id="testing-your-subscription"><a class="header" href="#testing-your-subscription">Testing Your Subscription</a></h2>
<p>Once you've created the subscription, any bio updates to your own profile will be delivered to your webhook endpoint. You should see events arrive in your webhook server logs.</p>
<p><strong>To test</strong>: Update your bio on X and watch for the event to arrive at your webhook!</p>
<h3 id="sample-event-payload"><a class="header" href="#sample-event-payload">Sample Event Payload</a></h3>
<p>When a profile bio update occurs, you'll receive a webhook event like this:</p>
<pre><code class="language-json">{
  "data": {
    "filter": {
      "user_id": "YOUR_USER_ID"
    },
    "event_type": "ProfileBioUpdate",
    "tag": "my bio updates",
    "payload": {
      "before": "vox populi",
      "after": "vox dei"
    }
  }
}
</code></pre>
<p>The event includes:</p>
<ul>
<li><strong><code>filter</code></strong>: The filter criteria that triggered this event</li>
<li><strong><code>event_type</code></strong>: The type of event that occurred</li>
<li><strong><code>tag</code></strong>: The tag you assigned to the subscription</li>
<li><strong><code>payload</code></strong>: The actual change data (before/after values)</li>
</ul>
<p>You can also list your active subscriptions again to confirm:</p>
<pre><code class="language-bash">xurl --auth app /2/activity/subscriptions
</code></pre>
<p>This will now show your active subscription in the response.</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Your XAA subscription is now active! Events will be delivered to your webhook as they occur. In production applications, you'll want to:</p>
<ol>
<li><strong>Handle multiple event types</strong> based on your use case</li>
<li><strong>Implement proper error handling</strong> for failed deliveries</li>
<li><strong>Monitor subscription health</strong> and revalidate when needed</li>
<li><strong>Clean up unused subscriptions</strong> to avoid hitting rate limits</li>
</ol>
<p>The X Activity API provides powerful real-time monitoring capabilities when combined with webhooks!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-new-trends-by-keyword-in-realtime"><a class="header" href="#getting-new-trends-by-keyword-in-realtime">Getting New Trends By Keyword in Realtime</a></h1>
<p>This chapter is a brief tutorial on how to use the X Activity API to get new trends emerging on X in realtime, filtered by keywords of your choice.</p>
<blockquote>
<p><strong>Note</strong>: This feature is currently only for Enterprise customers, but will hopefully be introduced to self-serve at some point.</p>
</blockquote>
<h2 id="subscribing-to-trends"><a class="header" href="#subscribing-to-trends">Subscribing to Trends</a></h2>
<p>You'll create a subscription to trends using the X Activity API in the same way you did in the last chapter.</p>
<p>This time, you'll use the <code>TrendsNew</code> event type, and you'll specify a <code>keyword</code> in the <code>filter</code> field instead of a user id:</p>
<pre><code class="language-bash">xurl --auth app /2/activity/subscriptions -X POST -d '{
  "event_type": "TrendsNew",
  "filter": {
    "keyword": "Tesla"
  },
  "tag": "Tesla trends",
  "webhook_id": "YOUR_WEBHOOK_ID"
}'
</code></pre>
<h3 id="success-response-1"><a class="header" href="#success-response-1">Success Response</a></h3>
<p>Upon success, you'll receive this response:</p>
<pre><code class="language-json">{
  "data": {
    "subscription": {
      "created_at": "2025-10-07T05:31:56Z",
      "event_type": "TrendsNew",
      "filter": {
        "keyword": "Tesla"
      },
      "subscription_id": "1146654567674912769",
      "tag": "Tesla trends",
      "updated_at": "2025-10-07T05:31:56Z",
      "webhook_id": "YOUR_WEBHOOK_ID"
    }
  },
  "meta": {
    "total_subscriptions": 1
  }
}
</code></pre>
<h3 id="getting-trend-events"><a class="header" href="#getting-trend-events">Getting Trend Events</a></h3>
<p>If you specified a webhook, then you'll start to see trends with a headline containing your keyword right away.</p>
<p>Trend events have this form:</p>
<pre><code class="language-json">{
  "data": {
    "event_uuid": "1985729017958244577",
    "filter": {
      "keyword": "news"
    },
    "event_type": "TrendsNew",
    "tag": "news trends",
    "payload": {
      "headline": "This is some news breaking on X",
      "summary": "Some new news broke on X today, which is an awesome place to go for breaking news!"
    }
  }
}
</code></pre>
<p>As the X Activity API matures, more fields will be added to the payload.</p>
<h3 id="duplicate-trends"><a class="header" href="#duplicate-trends">Duplicate Trends</a></h3>
<p>If you specified multiple subscriptions for trends, and a single trend event matches multiple subscriptions, it may be delivered multiple times.</p>
<p>Here's an example:</p>
<pre><code class="language-json">{
  "data": {
    "event_uuid": "1985729017958244577",
    "filter": {
      "keyword": "jack"
    },
    "event_type": "TrendsNew",
    "tag": "jack trends",
    "payload": {
      "headline": "New Jersey Gubernatorial Election Between Jack Ciattarelli and Mikie Sherrill",
      "summary": "Voters in New Jersey head to the polls to elect the state's next governor in a contest between Republican Jack Ciattarelli and Democratic incumbent Mikie Sherrill. Polls are open from 6 a.m. to 8 p.m. across the state."
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  "data": {
    "event_uuid": "1985729017958244577",
    "filter": {
      "keyword": "mikie"
    },
    "event_type": "TrendsNew",
    "tag": "mikie trends",
    "payload": {
      "headline": "New Jersey Gubernatorial Election Between Jack Ciattarelli and Mikie Sherrill",
      "summary": "Voters in New Jersey head to the polls to elect the state's next governor in a contest between Republican Jack Ciattarelli and Democratic incumbent Mikie Sherrill. Polls are open from 6 a.m. to 8 p.m. across the state."
    }
  }
}
</code></pre>
<p>You can see there are two separate subscriptions, one on the keyword <code>jack</code> and one on <code>mikie</code>. The headline in this trend contained both keywords, so it was delivered to the webhook twice.</p>
<p>X does some deduplication on its end, but you can use the <code>event_uuid</code> to do deduplication at the application layer as well.</p>
<h3 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h3>
<p>Setting up a trends feed using the X Activity API is a perfect way to integrate a live news feed of events you care about into your application!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
